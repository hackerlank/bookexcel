///
/// Generated by bookexcel
/// Do't modify this file directly, modify child class file instead
///

using System;
using System.Collections;
using System.Collections.Generic;
using LitJson;
using bookrpg.config;
using UnityEngine;

{%$filename = $className.$parentSuffix;%}
{% if ($package != ''): %}
namespace {%$package%} 
{
{% endif; %}
    public partial class {%:$managerClassName.$parentSuffix%} : 
        {% if ($TKey1 && $TKey2): %}
        {%$managerParentClass%}<{%$TKey1%}, {%$TKey2%}, {%$TItem%}>
        {% elseif ($TKey1): %}
        {%$managerParentClass%}<{%$TKey1%}, {%$TItem%}>
        {% else: %}
        {%$managerParentClass%}<{%$TItem%}>
        {% endif; %}
    {
        public {%:$managerClassName.$parentSuffix%}()
        {
            this.SetParser(new {%:ucfirst($fileFormat)%}Parser());
            this.resourceName = "{%$exportFile%}";
        }

        {% 
            $nameIndex = Array_search('itemName', $nameRow);
            $typeIndex = Array_search('itemType', $nameRow);
            $valueIndex = Array_search('itemValue', $nameRow);
            foreach ($dataRow as $row): 
            $type = $this->convertType($row[$typeIndex]);
            $name = $row[$nameIndex];
        %}
        public {%$type%} {%$name%} { get; protected set; }
        {% endforeach; %}

        public override bool Init(string text, string format=null)
        {
            if (base.Init(text, format)) {
                {% 
                    foreach ($dataRow as $row): 
                    $name = $row[$nameIndex];
                    $type = $this->convertType($row[$typeIndex]);
                %}
                this.{%$name%} = ({%$type%})GetItem("{%$name%}").value;
                {% endforeach; %}
                return true;
            }
            return false;
        }
    }

    public class {%:$className.$parentSuffix%} : {%$parentClassName%} 
    {
        public string key;
        public object value;

        ///parse form {%$fileFormat%} 
        public override bool ParseFrom(IConfigParser parser)
        {
            try{
                switch (parser.currentRow) 
                {
                    {%
                        $nameIndex = Array_search('itemName', $nameRow);
                        $typeIndex = Array_search('itemType', $nameRow);
                        $valueIndex = Array_search('itemValue', $nameRow);
                        $i = -1;
                        foreach ($dataRow as $row): 
                        $i++;
                        $name = $row[$nameIndex];
                        List($type, $arrDeep) = $this->convertType2($row[$typeIndex]);
                        $get = 'GetValue';
                        if ($arrDeep == 1) {
                            $get = 'GetList';
                        } Elseif($arrDeep > 1) {
                            $get = 'GetListGroup';
                        }
                    %}
                    case {%$i%}:
                        this.key = "{%$name%}";
                        if (parser.Has(this.key)) {
                            this.value = parser.{%$get%}<{%$type%}>(this.key);
                        } else {
                            this.value = parser.{%$get%}<{%$type%}>("itemValue");
                        }
                        break;
                    {% endforeach; %}
                }

                _key1 = key;
                return true;

            } catch(Exception e)
            {
                Debug.LogWarning(e.Message);
                return false;
            }
        }
    }
{% if ($package != ''): %}
}
{% endif; %}